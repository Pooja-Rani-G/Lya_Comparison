program PhotonsFromHaloes
  
  ! generate photons emitted by haloes within a given domain

  use module_utils
  use module_domain
  use module_random
  use module_constants
  use module_ramses
  
  implicit none
  
  type(domain)             :: emission_domain
  character(2000)          :: parameter_file
  real(kind=8),allocatable :: halo_pos(:,:),halo_pos_temp(:,:),halo_pos_dom(:,:)
  real(kind=8),allocatable :: halo_mass(:),halo_mass_temp(:),halo_mass_dom(:)
  real(kind=8),allocatable :: halo_vel(:,:),halo_vel_temp(:,:),halo_vel_dom(:,:)
  integer(kind=4)          :: i,n_haloes,n_haloes_dom,narg
  real(kind=8)             :: scalar, r2, temp(3)
  ! for analysis purposes (a posteriori weighting) we want to save the emitter-frame
  ! frequency (here the freq. in the emitting stellar particle's frame)
  real(kind=8),allocatable :: nu_source(:)
  real(kind=8)             :: tot_rel_lum, total_lum, M_halo_tot

  real(kind=8),allocatable :: low_prob(:), nu_em(:), sweight(:)
  real(kind=8),allocatable :: x_em(:,:), k_em(:,:)
  integer(kind=4)          :: ilow, iseed
  integer(kind=4)          :: iphot, j
  real(kind=8)             :: lambda,lambda0, k(3), nu, spec_gauss_nu0, weight
  
  ! --------------------------------------------------------------------------
  ! user-defined parameters - read from section [PhotonsFromHaloes] of the parameter file
  ! --------------------------------------------------------------------------
  ! --- input / outputs
  character(2000)           :: outputfile = 'PhotICs.dat' ! file to which outputs will be written
  character(2000)           :: haloesinfo = 'haloes_00005.dat'   !.dat file containing haloes information. To be generated by haloesinfo.py

  ! --- domain whithin which haloes will be selected (should be within computational domain used for RT). 
  character(10)             :: source_dom_type      = 'sphere'         ! shape type of domain  // default is sphere.
  real(kind=8),dimension(3) :: source_dom_pos       = (/0.5,0.5,0.5/)  ! center of domain [code units]
  real(kind=8)              :: source_dom_rsp       = 0.5              ! radius of spher [code units]
  real(kind=8)              :: source_dom_size      = 1.0              ! size of cube [code units]
    
  ! --- define how sources emit (i.e. the source-frame spectral shape)
  ! Four options here :
  ! - spec_type=='Mono'   : we emit all photons at the same wavelength (in source's frame)
  ! - spec_type=='PowLaw' : we sample a power-law continuum between two wavelengths. 
  character(30)             :: spec_type = 'Mono'               ! May be 'Mono', or 'PowLaw'.

  ! parameters for spec_type == 'Mono'
  real(kind=8)              :: spec_mono_lambda0 = 1215.67        ! emission wavelength [A]

  ! parameters for spec_type == 'PowLaw' : a power-law fit to continuum of each star particle, vs. its age and met.
  real(kind=8)              :: spec_powlaw_lmin = 1120.     ! min wavelength to sample (should be in the range where fit was made ...)
  real(kind=8)              :: spec_powlaw_lmax = 1320.     ! max ...
  real(kind=8)              :: spec_powlaw_beta = -2
  ! --- miscelaneous
  integer(kind=4)           :: nphotons = 1000000      ! number of photons to generate
  integer(kind=4)           :: ranseed  = -100         ! seed for random generator
  logical                   :: verbose  = .true.

  ! --------------------------------------------------------------------------
  
  
  ! -------------------- read parameters --------------------
  narg = command_argument_count()
  if(narg .lt. 1)then
     write(*,*)'You should type: PhotonsFromHaloes path/to/params.dat'
     write(*,*)'File params.dat should contain a parameter namelist'
     stop
  end if
  call get_command_argument(1, parameter_file)
  call read_PhotonsFromHaloes_params(parameter_file)
  if (verbose) call print_PhotonsFromHaloes_params
  ! ------------------------------------------------------------
  
  
  ! --------------------------------------------------------------------------------------
  ! define domain within which sources may shine
  ! --------------------------------------------------------------------------------------
  select case(source_dom_type)
  case('sphere')
     call domain_constructor_from_scratch(emission_domain,source_dom_type, &
          xc=source_dom_pos(1),yc=source_dom_pos(2),zc=source_dom_pos(3),r=source_dom_rsp)
  case('cube')
     call domain_constructor_from_scratch(emission_domain,source_dom_type, & 
          xc=source_dom_pos(1),yc=source_dom_pos(2),zc=source_dom_pos(3),size=source_dom_size)
  end select
  ! --------------------------------------------------------------------------------------
  
  
  ! --------------------------------------------------------------------------------------
  ! read haloes within domain
  ! --------------------------------------------------------------------------------------
  if (verbose) write(*,*) 'Reading haloes info file: ',trim(haloesinfo)
  open(unit = 10, file=trim(haloesinfo),status='old', form='unformatted',action='read')
  
  read(10) n_haloes
  allocate(halo_pos(n_haloes,3),halo_mass(n_haloes),halo_vel(n_haloes,3))

  do i=1,n_haloes
      read(10) halo_pos(i,:)
  enddo

  read(10) total_lum       !Luminosity in the full box (no.of photon/sec)

  do i=1,n_haloes
      read(10) halo_mass(i)
  enddo
  
  do i=1,n_haloes
      read(10) halo_vel(i,:)
  enddo  
  
  close(10)
  
  print*,'Total number of haloes read =',n_haloes
  print*,'Total box luminosity (no.of photon/sec) =', total_lum
  ! --------------------------------------------------------------------------------------
  !Now checking how many of the n_haloes are in the computational domain
  n_haloes_dom=0
  allocate(halo_pos_temp(n_haloes,3),halo_mass_temp(n_haloes),halo_vel_temp(n_haloes,3))
  do i=1,n_haloes
      temp(:) = halo_pos(i,:)
      if (domain_contains_point(temp,emission_domain)) then
          n_haloes_dom=n_haloes_dom+1
          halo_pos_temp(n_haloes_dom,:)=halo_pos(i,:)
          halo_mass_temp(n_haloes_dom)=halo_mass(i)
          halo_vel_temp(n_haloes_dom,:)=halo_vel(i,:)
      end if
  end do
  
  allocate(halo_pos_dom(n_haloes_dom,3))
  halo_pos_dom = halo_pos_temp(1:n_haloes_dom,:)
  
  allocate(halo_mass_dom(n_haloes_dom))
  halo_mass_dom = halo_mass_temp(1:n_haloes_dom)

  allocate(halo_vel_dom(n_haloes_dom,3))
  halo_vel_dom = halo_vel_temp(1:n_haloes_dom,:)  

  print*,'Total number of haloes read in computational domain =',n_haloes_dom

  M_halo_tot = sum(halo_mass_dom)
  print*,'Sum of halo masses (in solar mass units) =',M_halo_tot
  
  ! --------------------------------------------------------------------------------------
  ! Compute luminosity/spectrum for each star-particles
  ! --------------------------------------------------------------------------------------
  ! Replace the assignment 'sweight(i) = 1.0' with the relative luminosity due to each source
  ! for more sofisticated models.
  ! Note that tot_rel_lum should come out to be 1.


  select case(trim(spec_type))
!--------------------------------------------------------------------------------------
!--------------------------------------------------------------------------------------
  case('PowLaw')
     allocate(sweight(n_haloes_dom))
     
     do i = 1,n_haloes_dom
         sweight(i) = halo_mass_dom(i)/M_halo_tot
     enddo
     call compute_cum_low_prob(n_haloes_dom, sweight, low_prob, tot_rel_lum)
     
     allocate(x_em(1:3,1:nphotons), k_em(1:3,1:nphotons), nu_em(1:nphotons), nu_source(1:nphotons))
     
     iseed = ranseed
     do iphot = 1,nphotons

        call binary_search(iseed, n_haloes_dom, low_prob, ilow)
        ! draw photon's ICs from halo ilow

        ! give photon the position of the halo
        !print*,iphot,ilow
        x_em(:,iphot) = halo_pos_dom(ilow,:) 
        
        ! draw propagation direction
        call isotropic_direction(k,iseed)
        k_em(:,iphot) = k
        
        ! compute frequency in source frame
        r2=ran3(iseed)
        if (spec_powlaw_beta .ne. -2)then
            lambda=(spec_powlaw_lmin**(2+spec_powlaw_beta)+r2*(spec_powlaw_lmax**(2+spec_powlaw_beta)-spec_powlaw_lmin**(2+spec_powlaw_beta)))**(1/(2+spec_powlaw_beta))
        else
            lambda=spec_powlaw_lmin*(spec_powlaw_lmax/spec_powlaw_lmin)**r2
        endif
        nu_source(iphot) =  clight / (lambda*1e-8)  ! Hz
        
        ! compute frequency in external frame 
        scalar = k(1)*halo_vel_dom(ilow,1) + k(2)*halo_vel_dom(ilow,2) + k(3)*halo_vel_dom(ilow,3)
        nu_em(iphot)  = nu_source(iphot) / (1d0 - scalar/clight)
     end do

! --------------------------------------------------------------------------------------
! --------------------------------------------------------------------------------------
  case('Mono')
     
     print*,'Monochromatic spectral type'
     lambda0 = spec_mono_lambda0
     !call ssp_lib_extract_subset(lambda0, lambda0, NdotGrid) 
          
     allocate(sweight(n_haloes_dom))
     
     do i = 1,n_haloes_dom
         sweight(i) = halo_mass_dom(i)/M_halo_tot
     enddo
     call compute_cum_low_prob(n_haloes_dom, sweight, low_prob, tot_rel_lum)
     
     allocate(x_em(1:3,1:nphotons), k_em(1:3,1:nphotons), nu_em(1:nphotons), nu_source(1:nphotons))
     
     iseed = ranseed
     
     do iphot = 1,nphotons

        call binary_search(iseed, n_haloes_dom, low_prob, ilow)
        ! draw photon's ICs from halo ilow

        ! give photon the position of the halo
        !print*,iphot,ilow
        x_em(:,iphot) = halo_pos_dom(ilow,:) 
        ! draw propagation direction
        call isotropic_direction(k,iseed)
        k_em(:,iphot) = k
        ! compute frequency in star frame
        nu_source(iphot) =  clight / (lambda0*1e-8)  ! Hz
        ! compute frequency in external frame 
        scalar = k(1)*halo_vel_dom(1,ilow) + k(2)*halo_vel_dom(2,ilow) + k(3)*halo_vel_dom(3,ilow)
        nu_em(iphot)  = nu_source(iphot) / (1d0 - scalar/clight)
     end do

  end select
!--------------------------------------------------------------------------------------
!--------------------------------------------------------------------------------------


  ! --------------------------------------------------------------------------------------
  ! write ICs
  ! --------------------------------------------------------------------------------------
  if (verbose) then
     write(*,*) 'Writing file: ',trim(outputfile)
     write(*,*) ' '
  endif
  open(unit=14, file=trim(outputfile), status='unknown', form='unformatted', action='write')
  write(14) nphotons    ! nb of MC photons = nb of photon packets
  write(14) total_lum    ! nb of real photons in the box (per sec).
  write(14) ranseed
  write(14) (j,j=1,nphotons) ! ID
  write(14) (nu_em(j),j=1,nphotons)
  write(14) (x_em(:,j),j=1,nphotons)
  write(14) (k_em(:,j),j=1,nphotons)
!  write(14) (-j,j=1,nphotons) ! seeds
!  write(14) (nu_source(j),j=1,nphotons)
  close(14)
  ! --------------------------------------------------------------------------------------


  ! --------------------------------------------------------------------------------------
  ! deallocations 
  ! --------------------------------------------------------------------------------------
  deallocate(halo_pos,halo_pos_temp,halo_pos_dom)
  deallocate(halo_mass,halo_mass_temp,halo_mass_dom)
  deallocate(halo_vel,halo_vel_temp,halo_vel_dom)
  deallocate(sweight)
  deallocate(nu_source, nu_em, x_em, k_em)
  ! --------------------------------------------------------------------------------------

  
contains

  subroutine compute_cum_low_prob(n, weight, low_prob, cumtot)
    
    implicit none
    integer(kind=4),intent(in)                        :: n
    real(kind=8),dimension(n),intent(in)              :: weight
    real(kind=8),dimension(:),allocatable,intent(out) :: low_prob
    real(kind=8),intent(out)                          :: cumtot
    integer(kind=4)                                   :: i
    
    ! compute the total number of photons emitted per second by the sources
    cumtot = 0.0d0
    do i=1,n
       cumtot = cumtot + weight(i)
    end do
    
    ! calcul pour chaque particule la luminosite inferieure de son bin dans la distribution cumulative.. 
    allocate(low_prob(n+1))
    low_prob(1) = 0.0d0
    do i = 2,n
       low_prob(i) = low_prob(i-1) + weight(i-1)
    end do
    low_prob = low_prob / (low_prob(n)+weight(n))
    low_prob(n+1) = 1.1d0  ! higher than upper limit 
    
    return
  end subroutine compute_cum_low_prob
  
  
  subroutine binary_search(iseed, nbin, low_prob, ilow)
    
    implicit none
    integer(kind=4),intent(inout)             :: iseed
    integer(kind=4),intent(in)                :: nbin
    real(kind=8),intent(in),dimension(nbin+1) :: low_prob
    integer(kind=4),intent(out)               :: ilow
    integer(kind=4)                           :: iup, imid
    real(kind=8)                              :: mid, r1
    
    r1 = ran3(iseed)
    ! binary search
    iup = nbin+1
    ilow = 1
    do while (iup - ilow > 1)
       imid = (iup+ilow)/2
       mid  = low_prob(imid)
       if (r1 >= mid) then 
          ilow = imid
       else
          iup = imid
       end if
    end do
    ! check
    if (.not. (r1 >= low_prob(ilow) .and. r1 < low_prob(iup) )) then
       print*,'ERROR'
       stop
    end if
    return
  end subroutine binary_search
  
  
  subroutine read_PhotonsFromHaloes_params(pfile)

    ! ---------------------------------------------------------------------------------
    ! subroutine which reads parameters of current module in the parameter file pfile
    ! default parameter values are set at declaration (head of module)
    ! ---------------------------------------------------------------------------------

    character(*),intent(in) :: pfile
    character(1000) :: line,name,value
    integer(kind=4) :: err,i
    logical         :: section_present
    
    section_present = .false.
    open(unit=10,file=trim(pfile),status='old',form='formatted')
    ! search for section start
    do
       read (10,'(a)',iostat=err) line
       if(err/=0) exit
       if (line(1:19) == '[PhotonsFromHaloes]') then
          section_present = .true.
          exit
       end if
    end do

    ! read section if present
    if (section_present) then
       do
          read (10,'(a)',iostat=err) line
          if(err/=0) exit
          if (line(1:1) == '[') exit ! next section starting... -> leave
          i = scan(line,'=')
          if (i==0 .or. line(1:1)=='#' .or. line(1:1)=='!') cycle  ! skip blank or commented lines
          name=trim(adjustl(line(:i-1)))
          value=trim(adjustl(line(i+1:)))
          i = scan(value,'!')
          if (i /= 0) value = trim(adjustl(value(:i-1)))
          select case (trim(name))
          case ('outputfile')
             write(outputfile,'(a)') trim(value)
          case ('haloesinfo')
             write(haloesinfo,'(a)') trim(value)
          case ('source_dom_type')
             write(source_dom_type,'(a)') trim(value)
          case ('source_dom_pos')
             read(value,*) source_dom_pos(1),source_dom_pos(2),source_dom_pos(3)
          case ('source_dom_rsp')
             read(value,*) source_dom_rsp
          case ('source_dom_size')
             read(value,*) source_dom_size
          case ('spec_type')
             write(spec_type,'(a)') trim(value)
          case ('spec_mono_lambda0')
             read(value,*) spec_mono_lambda0
          case ('spec_powlaw_lmin')
             read(value,*) spec_powlaw_lmin
          case ('spec_powlaw_lmax')
             read(value,*) spec_powlaw_lmax
          case ('spec_powlaw_beta')
             read(value,*) spec_powlaw_beta
          case ('nPhotonPackets')
             read(value,*) nphotons
          case ('ranseed')
             read(value,*) ranseed
          case ('verbose')
             read(value,*) verbose
          case default
             write(*,'(a,a,a)') '> WARNING: parameter ',trim(name),' unknown '
          end select
       end do
    end if
    close(10)
    
    call read_ramses_params(pfile)
    
    return

  end subroutine read_PhotonsFromHaloes_params

  
  subroutine print_PhotonsFromHaloes_params(unit)

    ! ---------------------------------------------------------------------------------
    ! write parameter values to std output or to an open file if argument unit is
    ! present.
    ! ---------------------------------------------------------------------------------

    integer(kind=4),optional,intent(in) :: unit

    if (present(unit)) then 
       write(unit,'(a,a,a)')         '[PhotonsFromHaloes]'
       write(unit,'(a)')             '# input / output parameters'
       write(unit,'(a,a)')           '  outputfile      = ',trim(outputfile)
       write(unit,'(a,a)')           '  haloesinfo      = ',trim(haloesinfo)
       write(unit,'(a)')             '# computational domain parameters'
       write(unit,'(a,a)')           '  source_dom_type      = ',trim(source_dom_type)
       write(unit,'(a,3(ES10.3,1x))') '  source_dom_pos       = ',source_dom_pos(1),source_dom_pos(2),source_dom_pos(3)
       select case (trim(source_dom_type))
       case ('sphere')
          write(unit,'(a,ES10.3)')       '  source_dom_rsp       = ',source_dom_rsp
       case('cube')
          write(unit,'(a,ES10.3)')       '  source_dom_size      = ',source_dom_size
       end select
       write(unit,'(a)')             '# Spectral shape '
       write(unit,'(a,a)')           '  spec_type               = ',trim(spec_type)
       select case(trim(spec_type))
       case('Mono')
          write(unit,'(a,ES10.3,a)')     '  spec_mono_lambda0   = ',spec_mono_lambda0, ' ! [A]'
       case('PowLaw')
          write(unit,'(a,es10.3,a)')     '  spec_powlaw_lmin    = ',spec_powlaw_lmin, ' ! [A]' 
          write(unit,'(a,es10.3,a)')     '  spec_powlaw_lmax    = ',spec_powlaw_lmax, ' ! [A]'
          write(unit,'(a,es10.3,a)')     '  spec_powlaw_beta    = ',spec_powlaw_beta
       end select
       write(unit,'(a)')             '# miscelaneous parameters'
       write(unit,'(a,i8)')          '  nPhotonPackets  = ',nphotons
       write(unit,'(a,i8)')          '  ranseed         = ',ranseed
       write(unit,'(a,L1)')          '  verbose         = ',verbose
       write(unit,'(a)')             ' '
       call print_ramses_params(unit)
    else
       write(*,'(a)')             '--------------------------------------------------------------------------------'
       write(*,'(a)')             ' '
       write(*,'(a,a,a)')         '[PhotonsFromHaloes]'
       write(*,'(a)')             '# input / output parameters'
       write(*,'(a,a)')           '  outputfile      = ',trim(outputfile)
       write(*,'(a,a)')           '  haloesinfo      = ',trim(haloesinfo)
       write(*,'(a)')             '# computational domain parameters'
       write(*,'(a,a)')           '  source_dom_type      = ',trim(source_dom_type)
       write(*,'(a,3(ES10.3,1x))') '  source_dom_pos       = ',source_dom_pos(1),source_dom_pos(2),source_dom_pos(3)
       select case (trim(source_dom_type))
       case ('sphere')
          write(*,'(a,ES10.3)')       '  source_dom_rsp       = ',source_dom_rsp
       case('cube')
          write(*,'(a,ES10.3)')       '  source_dom_size      = ',source_dom_size
       end select
       write(*,'(a)')             '# Spectral shape '
       write(*,'(a,a)')           '  spec_type               = ',trim(spec_type)
       select case(trim(spec_type))
       case('Mono')
          write(*,'(a,ES10.3,a)')     '  spec_mono_lambda0       = ',spec_mono_lambda0, ' ! [A]'
       case('PowLaw')
          write(*,'(a,es10.3,a)')     '  spec_powlaw_lmin    = ',spec_powlaw_lmin, ' ! [A]' 
          write(*,'(a,es10.3,a)')     '  spec_powlaw_lmax    = ',spec_powlaw_lmax, ' ! [A]'
          write(*,'(a,es10.3,a)')     '  spec_powlaw_beta    = ',spec_powlaw_beta
       end select
       write(*,'(a)')             '# miscelaneous parameters'
       write(*,'(a,i10)')         '  nPhotonPackets  = ',nphotons
       write(*,'(a,i8)')          '  ranseed         = ',ranseed
       write(*,'(a,L1)')          '  verbose         = ',verbose
       write(*,'(a)')             ' '
       call print_ramses_params
       write(*,'(a)')             ' '
       write(*,'(a)')             '--------------------------------------------------------------------------------'
       write(*,'(a)')             ' '
    end if

    return

  end subroutine print_PhotonsFromHaloes_params

  
end program PhotonsFromHaloes
